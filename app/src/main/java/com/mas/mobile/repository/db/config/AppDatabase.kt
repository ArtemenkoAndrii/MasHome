package com.mas.mobile.repository.db.config

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase
import com.mas.mobile.repository.db.config.converter.SQLiteTypeConverter
import com.mas.mobile.repository.db.dao.BudgetDAO
import com.mas.mobile.repository.db.dao.ExpenditureDAO
import com.mas.mobile.repository.db.dao.IdGeneratorDAO
import com.mas.mobile.repository.db.dao.MessageRuleDAO
import com.mas.mobile.repository.db.dao.QualifierDAO
import com.mas.mobile.repository.db.dao.SettingsDAO
import com.mas.mobile.repository.db.dao.SpendingDAO
import com.mas.mobile.repository.db.dao.SpendingMessageDAO
import com.mas.mobile.repository.db.entity.Budget
import com.mas.mobile.repository.db.entity.ExpenditureData
import com.mas.mobile.repository.db.entity.IdGenerator
import com.mas.mobile.repository.db.entity.MessageRule
import com.mas.mobile.repository.db.entity.Qualifier
import com.mas.mobile.repository.db.entity.Settings
import com.mas.mobile.repository.db.entity.SpendingData
import com.mas.mobile.repository.db.entity.SpendingMessage
import com.mas.mobile.util.CurrencyTools
import java.time.LocalDate

@Database(
    version = 7,
    exportSchema = true,
    entities = [
        Budget::class,
        SpendingData::class,
        ExpenditureData::class,
        SpendingMessage::class,
        MessageRule::class,
        Settings::class,
        IdGenerator::class,
        Qualifier::class
        ]
)
@TypeConverters(SQLiteTypeConverter::class)
abstract class AppDatabase : RoomDatabase() {
    companion object {
        private var INSTANCE: AppDatabase? = null
        const val AUTOGENERATED = 0

        fun getInstance(context: Context): AppDatabase {
            if (INSTANCE == null) {
                INSTANCE = Room.databaseBuilder(context, AppDatabase::class.java, "mas_home.db")
                    .allowMainThreadQueries()
                    .addCallback(object : Callback() {
                        override fun onCreate(db: SupportSQLiteDatabase) {
                            super.onCreate(db)
                            db.execSQL(DML.TEMPLATE_GENERATOR)
                            db.execSQL(DML.TEMPLATE_BUDGET)
                            db.execSQLs(DML.TEMPLATE_EXPENDITURES)
                            db.execSQLs(DML.GREETING_MESSAGE_RULES)
                            db.execSQLs(DML.DEFAULT_QUALIFIERS)
                        }
                    })
                    .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5, MIGRATION_5_6, MIGRATION_6_7,)
                    .build()
            }
            return INSTANCE!!
        }
    }

    abstract fun budgetDao(): BudgetDAO
    abstract fun expenditureDao(): ExpenditureDAO
    abstract fun spendingDao(): SpendingDAO
    abstract fun spendingMessageDao(): SpendingMessageDAO
    abstract fun messageRuleDao(): MessageRuleDAO
    abstract fun settingsDao(): SettingsDAO
    abstract fun idGeneratorDAO(): IdGeneratorDAO
    abstract fun qualifierDAO(): QualifierDAO
}

internal fun SupportSQLiteDatabase.execSQLs(sqlBlock: String): Unit =
    sqlBlock
        .split(";")
        .filter { it.isNotBlank() }
        .forEach { this.execSQL(it.trim()) }

val MIGRATION_1_2 = object : Migration(1, 2) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("CREATE TABLE generator (id INTEGER NOT NULL, PRIMARY KEY(`id`))")
        database.execSQL("INSERT INTO generator(id) VALUES(1000)")
    }
}

val MIGRATION_2_3 = object : Migration(2, 3) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("ALTER TABLE spending_messages ADD COLUMN status TEXT NOT NULL DEFAULT 'MATCHED'")
    }
}

val MIGRATION_3_4 = object : Migration(3, 4) {
    private val maxDate = SQLiteTypeConverter().fromLocalDate(LocalDate.MAX)

    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("UPDATE budgets SET startsOn=$maxDate WHERE id=1")
    }
}

val MIGRATION_4_5 = object : Migration(4, 5) {
    override fun migrate(database: SupportSQLiteDatabase) {
        with(database) {
            execSQL("CREATE TABLE qualifiers (name TEXT NOT NULL PRIMARY KEY, type INTEGER NOT NULL)")
            execSQLs(DML.DEFAULT_QUALIFIERS)
        }
    }
}

val MIGRATION_5_6 = object : Migration(5, 6) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("CREATE INDEX IF NOT EXISTS index_expenditures_on_budget_id ON expenditures(budget_id)")
        database.execSQL("CREATE INDEX IF NOT EXISTS index_spendings_on_expenditure_id ON spendings(expenditure_id)")
    }
}

val MIGRATION_6_7 = object : Migration(6, 7) {
        override fun migrate(database: SupportSQLiteDatabase) {
            val currency = CurrencyTools.getDefaultCurrency()
            database.execSQL("ALTER TABLE budgets ADD COLUMN currency TEXT NOT NULL DEFAULT '$currency'")
            database.execSQL("ALTER TABLE message_rules ADD COLUMN currency TEXT NOT NULL DEFAULT '$currency'")
            database.execSQL("ALTER TABLE spendings ADD COLUMN currency TEXT DEFAULT NULL")
            database.execSQL("ALTER TABLE spendings ADD COLUMN rate REAL DEFAULT NULL")
            database.execSQL("ALTER TABLE spendings ADD COLUMN foreignAmount REAL DEFAULT NULL")
    }
}
